\documentclass{amsart}
\usepackage[letterpaper, portrait, margin=1in]{geometry}

%----------Packages----------
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[mathcal]{eucal}
\usepackage{verbatim}  %%includes comment environment
\usepackage[parfill]{parskip}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{etoolbox}
\makeatletter
\patchcmd{\@maketitle}
  {\ifx\@empty\@dedicatory}
  {\ifx\@empty\@date \else {\vskip3ex \centering\footnotesize\@date\par\vskip1ex}\fi
   \ifx\@empty\@dedicatory}
  {}{}
\patchcmd{\@adminfootnotes}
  {\ifx\@empty\@date\else \@footnotetext{\@setdate}\fi}
  {}{}{}
\makeatother
%----------Commands----------

%%penalizes orphans
\clubpenalty=9999
\widowpenalty=9999

%% bold math capitals
\newcommand{\bA}{\mathbf{A}}
\newcommand{\bB}{\mathbf{B}}
\newcommand{\bC}{\mathbf{C}}
\newcommand{\bD}{\mathbf{D}}
\newcommand{\bE}{\mathbf{E}}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bG}{\mathbf{G}}
\newcommand{\bH}{\mathbf{H}}
\newcommand{\bI}{\mathbf{I}}
\newcommand{\bJ}{\mathbf{J}}
\newcommand{\bK}{\mathbf{K}}
\newcommand{\bL}{\mathbf{L}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bN}{\mathbf{N}}
\newcommand{\bO}{\mathbf{O}}
\newcommand{\bP}{\mathbf{P}}
\newcommand{\bQ}{\mathbf{Q}}
\newcommand{\bR}{\mathbf{R}}
\newcommand{\bS}{\mathbf{S}}
\newcommand{\bT}{\mathbf{T}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bV}{\mathbf{V}}
\newcommand{\bW}{\mathbf{W}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\bY}{\mathbf{Y}}
\newcommand{\bZ}{\mathbf{Z}}

%% blackboard bold math capitals
\newcommand{\bbA}{\mathbb{A}}
\newcommand{\bbB}{\mathbb{B}}
\newcommand{\bbC}{\mathbb{C}}
\newcommand{\bbD}{\mathbb{D}}
\newcommand{\bbE}{\mathbb{E}}
\newcommand{\bbF}{\mathbb{F}}
\newcommand{\bbG}{\mathbb{G}}
\newcommand{\bbH}{\mathbb{H}}
\newcommand{\bbI}{\mathbb{I}}
\newcommand{\bbJ}{\mathbb{J}}
\newcommand{\bbK}{\mathbb{K}}
\newcommand{\bbL}{\mathbb{L}}
\newcommand{\bbM}{\mathbb{M}}
\newcommand{\bbN}{\mathbb{N}}
\newcommand{\bbO}{\mathbb{O}}
\newcommand{\bbP}{\mathbb{P}}
\newcommand{\bbQ}{\mathbb{Q}}
\newcommand{\bbR}{\mathbb{R}}
\newcommand{\bbS}{\mathbb{S}}
\newcommand{\bbT}{\mathbb{T}}
\newcommand{\bbU}{\mathbb{U}}
\newcommand{\bbV}{\mathbb{V}}
\newcommand{\bbW}{\mathbb{W}}
\newcommand{\bbX}{\mathbb{X}}
\newcommand{\bbY}{\mathbb{Y}}
\newcommand{\bbZ}{\mathbb{Z}}

%% script math capitals
\newcommand{\sA}{\mathscr{A}}
\newcommand{\sB}{\mathscr{B}}
\newcommand{\sC}{\mathscr{C}}
\newcommand{\sD}{\mathscr{D}}
\newcommand{\sE}{\mathscr{E}}
\newcommand{\sF}{\mathscr{F}}
\newcommand{\sG}{\mathscr{G}}
\newcommand{\sH}{\mathscr{H}}
\newcommand{\sI}{\mathscr{I}}
\newcommand{\sJ}{\mathscr{J}}
\newcommand{\sK}{\mathscr{K}}
\newcommand{\sL}{\mathscr{L}}
\newcommand{\sM}{\mathscr{M}}
\newcommand{\sN}{\mathscr{N}}
\newcommand{\sO}{\mathscr{O}}
\newcommand{\sP}{\mathscr{P}}
\newcommand{\sQ}{\mathscr{Q}}
\newcommand{\sR}{\mathscr{R}}
\newcommand{\sS}{\mathscr{S}}
\newcommand{\sT}{\mathscr{T}}
\newcommand{\sU}{\mathscr{U}}
\newcommand{\sV}{\mathscr{V}}
\newcommand{\sW}{\mathscr{W}}
\newcommand{\sX}{\mathscr{X}}
\newcommand{\sY}{\mathscr{Y}}
\newcommand{\sZ}{\mathscr{Z}}


\renewcommand{\phi}{\varphi}

\renewcommand{\emptyset}{\O}

\providecommand{\abs}[1]{\lvert #1 \rvert}
\providecommand{\norm}[1]{\lVert #1 \rVert}


\providecommand{\sarr}{\rightarrow}
\providecommand{\arr}{\longrightarrow}

\renewcommand{\_}[1]{\underline{ #1 }}
\providecommand{\rap}{\rightleftharpoons}

\def\inprobLOW{\rightarrow_p}
\def\inprobHIGH{\,{\buildrel p \over \rightarrow}\,} 
\def\inprob{\,{\inprobHIGH}\,} 

\def\indistLOW{\rightarrow_d}
\def\indistHIGH{\,{\buildrel d \over \rightarrow}\,} 
\def\indist{\,{\indistHIGH}\,} 


\DeclareMathOperator{\ext}{ext}



%----------Theorems----------

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lemma}[thm]{Lemma}
\newtheorem{corollary}[thm]{Corollary}


\newtheorem*{axiom4}{Axiom 4}


\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{nondefinition}[thm]{Non-Definition}
\newtheorem{exer}[thm]{Exercise}
\newtheorem{rmk}[thm]{Remark}
\newtheorem{warning}[thm]{Warning}
\newtheorem{exmps}[thm]{Examples}
\newtheorem{exmp}[thm]{Example}
\numberwithin{equation}{subsection}


\begin{document}

\title{Case 2: Pairs Trading}
\maketitle

\setlength{\parindent}{0.5cm}
\section{Introduction}
This case examines how an understanding of the relationship between securities can be used to attain profits when prices deviate from the equilibrium.  \\

Each team will be allowed to trade a portfolio of stocks in each round of the case. Your algorithm should be able to identify the profitable trading pairs within the portfolio of securities, discover the underlying relationship and profit from it, at the same time managing your exposure to secure the profit before the deviation reverts. \\

The case will consist of three rounds with 1,000 ticks each. (1) The first round will consist of only two securities with a pre-established relationship. Your job is to study it and profit from any deviations from its equilibrium. (2) In the second round, there will be three tradable securities so your job extends to being able to identify the {\it one} trading pair (and the third security,  which has no meaningful relationship with the other two) and profit from it. (3) The third round will have five tradable securities available with {\it two} distinct trading pairs for your algorithm to tackle. \\

\begin{center}
    \begin{tabular}{ | l | c | c | c | c | c |}
    \hline
    Securities & S1 & S2 & S3 & S4 & S5 \\ \hline
	Starting Price for Round 1  & X & Y & - & - & -\\ \hline
	Starting Price for Round 2  & X & Y & Z & - & - \\ \hline
	Starting Price for Round 3 & X & Y & Z & W & R\\
    \hline
    \end{tabular}
\newline
\end{center}
 

\section{Addtional Details}
To discourage running algorithm that only trades one particular security instead of attempting to discover a profitable pair, data for each individual security will be generated from a process where the expected returns are 0.
\\

In addition, you must maintain a net zero position at all times. Hence, when you buy a security, you have to simultaneously sell another security (and vice versa). \\

An absolute position limit will also be enforced so there will be a limit to how large a directional position may be. This constraint means your algorithm should allocate your exposure to where it thinks the most profitable trades will lie. \\

There will be a fixed bid-ask spread around the price of each security. \\

Participants will be given sample data generated from our algorithm to test run their program, but we may change the parameters used on the competition day.  You will be provided with adequate capital at the beginning of each round to establish positions within the limits set forth above. Positions and {\it PnL} are not carried over between rounds. Any open positions will be liquidated at the closing price of each security at the end of each round. Teams will have time between rounds to make changes to their parameters used in their algorithm if they choose.  

\section{Scoring}
Participants' scores in each round of the case will be determined based on $PnL$, where $PnL$ is defined to include profits and losses from closed positions, as well as profits and losses from any open positions at the end of the round marked to the closing price of each security of that round. 
\\

The weighting of the scores from each round to calculate the final score of the case will be announced prior to the start of the competition. 


\section{Case Objects $\&$ Interface}

The following Java class objects are implemented in the util package and should be used in your program based on the interface defined:

\begin{verbatim}
    public enum Ticker {
        S1, S2, S3, S4, S5
    }
\end{verbatim}

Only the securities relevant will be available during each round.  

\begin{verbatim}
    public static class Quote {
        public Quote(Ticker ticker, double bid, double offer)
    }

    public static class Order {
        public Order (Ticker ticker, int quantity)
    }

\end{verbatim}

Your program only needs to expose the following functions:
\begin{verbatim}
    public Order[] getNewQuotes(Quote[] quotes);
\end{verbatim}

This method is called when new quotes for the stocks are distributed. New price information will be passed on via the quotes array argument. You implementation should return an array of orders indicating your actions for each of the stocks. 1 for buy, -1 for sell and 0 for inaction. Please make sure the order of the securities in your returned array be the same as in the Quotes array you receive, which will be consistent. 

\begin{verbatim}
    public void orderFill (Order[] orders);
\end{verbatim}

This function is invoked to confirm that the orders you submitted were filled. The reason that this second function is needed is due to the case that the order of securities in the returned array is different from the \verb Quote  the system sends out.  
 
\end{document}